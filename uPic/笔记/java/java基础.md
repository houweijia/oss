### 一、虚拟机栈相关问题

#### 1.什么情况下会发生栈内存溢出？
在jvm运行时的数据区中有一个java虚拟机栈，当执行java方法时会进行压栈和弹栈的操作。在栈中会保存局部变量，操作数栈，方法出口等等。jvm规定了栈的最大深度，当执行时栈的最大深度超过了规定的深度时，就会抛出StackOverflowError错误。

- 典型例子：递归调用
```
public class StackOverFlowDemo {
 
    public static void Foo(){
        Foo();
    }
 
    public static void main(String[] args) {
        Foo();
    }
}
```
- 是否有大量循环或死循环
- 数组、List、map数据是否过大
- 是否有大量循环或死循环

#### 2.如果让你写一段栈溢出的代码你会什么写，一个栈大概有多大，为什么？每个线程都有这样大小的一个栈吗

代码同上一题，


3.jvm结构图

![jvm图1](https://raw.githubusercontent.com/houweijia/oss/main/uPic/jvm图1.png)
![jvm图2](https://raw.githubusercontent.com/houweijia/oss/main/uPic/jvm图2.jpeg)
![jvm3](https://raw.githubusercontent.com/houweijia/oss/main/uPic/jvm3.png)

1.程序计数器（线程私有的）

程序计数器(Program Counter Register)，是一块很小内存空间，可以看作是当前线程锁执行的字节码的行号指示器。在虚拟机的概念模型中字节码解释器的工作就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖于此计数器。JVM中的程序计数器也是在Java虚拟机规范中唯一一个没有规定任何OOM情况的区域。在任意时刻一条JVM线程只能执行一个方法的代码，方法可以是Java方法，或者是native方法。

需要注意的是：
- java虚拟机中的程序计数器仅仅是虚拟机中的，存在于内存之上的"虚拟"计数器，而不是电脑中的实体程序计数器
- Jvm线程 中执行的方法有两种类型，普通Java方法和由其他语言实现的native方法。如果当前执行的是普通方法，那么程序计数器记录的是虚拟机字节码指令的地址。如果当前执行的是native方法，则计数器的值为空(Undefined) （native方法多由C和C++语言实现，比如java.lang.Object类中的hashCode()方法就是native方法，其底层是通过C++实现）

2.Java虚拟机栈

和程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，即生命周期和线程相同。Java虚拟机栈和线程同时创建，用于存储栈帧。每个方法在执行时都会创建一个栈帧(Stack Frame),用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直到执行完成的过程就对应着一个栈帧在虚拟机中从入栈到出栈的过程。

Java虚拟机规范中，Java虚拟机栈内存的大小既可以被实现成固定大小，也可以根据计算动态拓展或收缩，当前大部分的JVM实现是支持动态拓展的。Java虚拟机栈可能发生的异常：

- 线程请求分配的栈容量>Java虚拟机最大栈容量，则JVM会抛出StackOverFlowError异常
- 如果java虚拟机可动态扩展，则如果在拓展的过程中无法申请到足够的内存，就会抛出OutOfMemoryError异常

3.本地方法栈

本地方法栈(Native Method Stack)和Java虚拟机栈类似，区别在于Java虚拟机栈是为了Java方法服务的，而本地方法栈是为了native方法法务的。在虚拟机规范中并没有对本地方法实现所采用的编程语言与数据结构采取轻质规定，因此不同的JVM虚拟机可以自己实现自己的native方法。此处需要说明：Sun HotSpot虚拟机就直接将本地方法栈和Java虚拟机栈合二为一了。

##### 栈帧结构

一个栈帧需要分配多少内存，不会受到程序运行时变量数据影响，仅仅取决于虚拟机的实现

##### 局部变量表(Local Variable Table)

- 在编译代码的时候就可以确定栈帧需要多大的局部变量表，具体的大小可以在编译后的class文件中看到
- 局部变量表容量以变量槽(Variable Slot)为最小单位，每个变量槽都可以存储32位长度的内存空间
- 在方法执行的时候，虚拟机使用局部变量表完成参数值到参数变量表的传递过程，如果执行的是实例方法，那局部变量表的第0个槽位索引默认是用于传递方法所属对象的引用(this关键字)，其余参数则按照参数顺序排列，占用从1开始的局部变量表Slot
- 基本数据类型以及引用和返回地址(returnAddress)占用一个变量槽，long和double占两个

###### 操作数栈（Operand Stack）

- 也是在编译期间就可以确定大小
- 栈帧被创建时，操作数栈是空的。操作数栈的每个定都可以存放JVM各种类型的数据，long和double则栈深（和局部变量表是一样的，因为long、double都是64位的数据）
- 方法执行的过程中，随着各个指令的执行，会有各种数据往操作数栈中写入和读取，也就是出栈和入栈的操作
- 操作数栈调用其他有返回结果的方法时，会把结果push到栈上（通过操作数栈进行参数传递）

###### 动态链接（Dynamic Linking）

- 动态链接设计到java的多态特性，动态链接的说明是栈帧内部包含一个指向运行时常量池中该栈帧所属方法的引用，该引用的目的是为了支持动态代理

###### 完成出口（也叫返回地址 Return Address）

- 方法执行完成的出口，只能由2种方式退出：return返回指令和异常退出
- 正常退出的流程是，将调用方法的返回值(如果有的话)，压入被调用方法的操作数栈顶，被调用的方法根据程序计数器继续执行

4.Java堆

前面所说的程序计数器、Java虚拟机栈、本地方法栈通常只占很小一部分的内存空间，对与大多数应用来说，Java堆（Java Heap）才是Jvm管理的内存空间中最大的一块。此区域存在的唯一目的就是存放对象实例，几乎所有的对象实例都会在这被分配内存，而且Java堆是被所有线程共享的一块内存区域。

Java堆是Java垃圾收集器管理的主要区域，因此也被称为GC堆-Garbage Collected Heap.

根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存之中，只要逻辑上是连续的即可。且和栈一样，不同的JVM实现可以有不同的内存策略，Java堆得内存既可以设计成固定大小，也可以动态拓展。

5.方法区

方法区(Method Area)，与java堆一样是各个线程共享的内存区域，用于存储被JVM加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

在Java7以前，HotSpot虚拟机中，方法区也被称为"永久代"，因为在物理上，方法区使用的是由JVM开辟的堆内存，由于和Java堆共享内存且内存空间由垃圾收集器 同意分配和管理（堆和方法区是连续的），自然地垃圾收集也拓展到了方法区上。此时，Java堆中分区为青年代和老年代，而方法区自然地被称为永久代。（JVM虚拟机有不同的实现，比较主流的是sun公司的HotSpot虚拟机，在此才有"永久代"的概念，其他虚拟机不存在这个概念）

在Java8中，HotSpot虚拟机改变了原有方法区的物理实现，将原来由本JVM管理内存的方法区的内存移到了虚拟机以外的计算机本地内存，并将其称为元空间(Metaspace)。这样一来，现在的方法区实现实际存储在于元空间，再也不用和Java堆共享内存了。"永久代"也就永久地被撤销了。(尽管永久代取消了，但是方法区的这个逻辑上的空间一直存在，所以在Java8以后，方法区的垃圾回收在物理上就是对元空间的垃圾回收，元空间的大小可以通过参数设定，如果元空间的空间占用达到了设定的最大值，那么就会触发GC来收集死亡对象和类的加载器)

##### 相关面试题

为什么用元空间替换永久代

- 在之前的版本中，字符串常量池存在于永久代中，在大量使用字符串的情况下，非常容易出现OOM的异常。此外，JVM加载的class的总数，方法的大小等都很难确定，因此对永久代大小的指定难以确定。太小的永久代容易导致永久代内存溢出，太大的永久代则容易导致虚拟机内存紧张。

5.1运行时常量池

运行时常量池（Runtime Constant Pool）是.class文件中每一个类或接口的常量池表（constant pool table）的运行时表示形式，**属于方法区的一部分***。每一个运行时常量池都在Java虚拟机的方法区中分配，在加载类和接口到虚拟机后，就创建对应的运行时常量池。

**运行时常量池和字符串常量池的版本变化**

https://blog.csdn.net/qq_45737068/article/details/107149922

https://juejin.cn/post/6854573216824819719

- 在JDK1.7之前运行时常量池逻辑包含字符串常量池存放在方法区，此时hotspot虚拟机堆方法区的实现为永久代
- 在JDK1.7字符串常量池被从方法区拿到了堆中，这里没有提到运行时常量池，也就是说 字符串常量池被单独拿到堆中，运行时常量池剩下的部分还在方法区，也就是hotspot中的永久代
- 在JDK1.8hotspot移除了永久代用元空间(Metaspace)取而代之，这时候字符串常量池还在堆，运行时常量池还在方法区，只不过方法区的实现从永久代变成了元空间(Metaspace)


##### 4.Java虚拟栈相关面试题

1.举例栈溢出的情况?(StackOverflowError)
- 递归调用等，通过-Xss设置栈的大小；

2.调整栈的大小，就能保证不出现溢出么？
- 不能 如递归无限次数肯定会溢出，调整栈大小只能保证溢出的时间晚一些，极限情况会导致OOM内存溢出(Out Of Memery Error)

3.分配的栈内存越大越好么？

- 不是 会挤占其他线程的空间

4.垃圾回收是否会涉及到虚拟机栈？

- 不会



#### 3.JVM中一次完整的GC流程是怎么样的，对象如何晋升到老年代

**Minor GC**：从年轻代空间(包括Eden和Survivor区域)回收内存被称为Minor GC。当JVM无法为一个新的对象分配空间时会触发Minor GC，比如当Eden区满了。所以分配率越高，越频繁执行Minor GC

**Major GC**：老年代的垃圾收集叫做Major GC，Major GC通常是跟full GC是等价的，收集整个GC堆。

**Full GC**：针对整个新生代、老年代、元空间（metaspace，java8以上版本取代perm）的全局范围的GC

![堆内存结构图](https://raw.githubusercontent.com/houweijia/oss/main/uPic/堆内存结构图.png)

1.年轻代

年轻代被分为3个部分，Eden区和两个Survivor区，年轻代空间的要点

- 大多数新建的对象都位于Eden区
- 当Eden区被对象填满时，就会执行Minor GC，并把所有存活下来的对象转移到其中一个survivor区
- Minor GC同样会检查存活下来的对象，并把它们转移到另一个survivor区。这样在一段时间内，总会有一个空的survivor区。
- 经过多次GC周期后，仍然存活下来的对象会被转移到老年代
- Minor GC回收年轻代采用复制回收算法的改进版本，from区和to区的两个交换区，这两个区只有一个区有数据。采用8:1:1的默认分配比例

问题

1.新生代为什么会有两个survivor区域

新生代在发生首次MinorGC的时候，Eden内存活的对象会被复制到S1，再发生MinorGC的时候，Eden内存活的对象和S1内存活的对象被复制到S2，同时清除Eden内的对象和S1内的对象，再发生MinorGC的时候，Eden内存活的对象和S2内存活的对象会被复制到S1，同时清除Eden内的对象和S2内的对象，以此往复循环，生存次数超过阈值(大概是15，每经历以此MinorGC增加1)的对象进入老年代。可以总结得出，每次MinorGC发生之后，S1和S2总会有一个是空的，其目的是避免内存碎片化带来的空间与性能损失。可能有人会问，我们也可以在每次MinorGC的时候，堆S区内的对象进行重排序，使得S区内的对象紧挨着彼此，避免内存碎片化，这个想法没什么问题，但是要考虑到MinorGC是JVM垃圾回收中最最最频繁的活动，如果每次都要话费这么多的时间去重排序对象，对象重排序相比直接复制，是很耗时的计算，因此划分出两个S区域，以空间为代价(每次都有一个S区为空)换取GC时间，是很值得的事情，提升了服务器响应性。
